/*
 * assembler.c: assembler for an imaginary CPU
 *
 * This is kept here for my sanity, it doesn't do
 * anything spectacular on its own.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <strings.h>

#include "../opcodes.h"

struct label_t {
  char *name;
  char pos;
  int len;
};

int main(int argc, char **argv){
  FILE *fp, *fout;
  char buf[512],
       inst[16],
       outname[32],
       *ptr, *tmp,
       ip = sizeof(struct program_t);
  int i,
      arg1, arg1_t,
      arg2, arg2_t,
      pos,
      lind = 0,
      line = 0;
  struct program_t prog;
  struct label_t labels[256];

  if(argc < 2){
    printf("Usage: assembler [file.S]\n");
    return 1;
  }

  sprintf(outname, "%s.bin", argv[1]);
  fout = fopen(outname, "w");

  fseek(fout, sizeof(struct program_t), SEEK_SET);

  /* First pass: find label definitions */
  fp = fopen(argv[1], "r");
  while(fgets(buf, sizeof(buf), fp) != NULL){
    tmp = strdup(buf);
    while(*tmp == ' ') tmp++;
    if(*tmp == '@'){
      labels[lind].name = strdup(tmp); /* TODO: This leaks memory */
      labels[lind].len = strlen(tmp)-2;
      labels[lind].pos = 0; /* This is a signal that the position is currently invalid (pos 0 is start of binary header) */
      labels[lind].name[labels[lind].len] = '\0';
      lind++;
    }
  }

  fseek(fp, 0, SEEK_SET);
  while(fgets(buf, sizeof(buf), fp) != NULL){
    ip += sscanf(buf, "%s %s %s", &inst, &arg1, &arg2);
  }

  /* Third pass: assemble */
  /*
  fseek(fp, 0, SEEK_SET);
  while(fgets(buf, sizeof(buf), fp) != NULL){
    line++;
    ptr = malloc(512);
    memcpy(ptr, buf, sizeof(buf));
    memset(inst, 0, sizeof(inst));
    i = 0;
    arg1 = 0;
    arg1_t = NONE;
    arg2 = 0;
    arg2_t = NONE;

    if((tmp=strchr(ptr, ';')) != NULL) tmp[0] = '\0';

    while(*ptr == ' ') ptr++;
    while(*ptr != ' ' && *ptr != '\n' && *ptr != '\0') inst[i++] = *ptr++;
    if(inst[0] == '@'){
      for(i=0;i<lind;i++){
        if(strncmp(labels[i].name, inst, labels[i].len) == 0){
          labels[i].pos = ip;
        }
      }
      continue;
    } else inst[i] = '\0';
    while(*ptr == ' ') ptr++;
    if(*ptr == '\n' || *ptr == '\0') goto search;
    if(*ptr == 'r'){
      arg1_t = REG;
      ptr++;
    } else arg1_t = VAL;
    if(*ptr == '@'){
      for(i=0;i<lind;i++){
        if(strncmp(labels[i].name, ptr, labels[i].len) == 0){
          arg1 = labels[i].pos;
          goto search;
        }
      }
      printf("Error: Unable to find label \"%s\" referenced on line %i.\n", ptr, line);
      fclose(fp);
      fclose(fout);
      exit(1);
    } else {
      sscanf(ptr, "%i%n", &arg1, &pos);
      ptr += pos;
    }
    while(*ptr == ' ' || *ptr == ',') ptr++;
    if(*ptr == '\n' || *ptr == '\0') goto search;
    if(*ptr == 'r'){
      arg2_t = REG;
      ptr++;
    } else arg2_t = VAL;
    sscanf(ptr, "%i", &arg2);

search:;
    printf("%s %i %i\n", inst, arg1, arg2);
    for(i=0;i<LENGTH(instructions);i++){
      if(instructions[i].arg1 == arg1_t &&
         instructions[i].arg2 == arg2_t &&
         strcasecmp(instructions[i].inst, inst) == 0){
        fputc(instructions[i].opcode, fout);
        ip++;
        if(arg1_t != NONE){
          fputc(arg1, fout);
          ip++;
        }
        if(arg2_t != NONE){
          fputc(arg2, fout);
          ip++;
        }
        break;
      }
    }
  }*/

  fseek(fout, 0, SEEK_SET);
  prog.text_start = 0;
  prog.text_length = 0;
  prog.data_start = 0;
  prog.data_length = 0;
  for(i=0;i<lind;i++){
    if(strncmp(labels[i].name, "@start", labels[i].len) == 0){
      prog.entry_point = labels[i].pos;
      fwrite(&prog, sizeof(struct program_t), 1, fout);
      goto found_start;
    }
  }

  printf("Warning: Did not find @start label, defaulting entry point to 0x05.\n");
  prog.entry_point = 0x05;
  fwrite(&prog, sizeof(struct program_t), 1, fout);

found_start:;
  printf("Successfully assembled %s.\n", outname);
  fclose(fp);
  fclose(fout);

  return 0;
}
